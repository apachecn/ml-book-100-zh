# Chapter 1  导论  
##   

## 1.1 机器学习是什么？   

机器学习是一个与构建算法有关的计算机科学的子领域，这些算法很有用，它依赖于某些现象的实例收集是有用的。这些实例可以来自自然，由人类手工设计或由另一种算法产生。  

机器学习也可以定义为通过收集数据集来解决实际问题的过程。假设这个统计模型是用来解决实际问题的。  

我交替使用“学习”和“机器学习”这两个术语。  
## 1.2学习类型  
学习可以是监督的、半监督的、非监督的和强化的。  

### 1.2.1 监督学习  

在**监督学习**中，**数据集**是**标签示例**{（x<sub>i</sub>，y<sub>i</sub>）} <sup>N</sup><sub>i=1</sub>的集合。(如果术语以**粗体**显示，则表示该术语可以在本书末尾的索引中找到。)

N中的每个元素x<sub>i</sub>称为**特征向量**。特征向量是这样的一种向量，它每个维度j = 1，...D包含一个以某种方式描述该样本的值。这些值被称为**特征**，表示为x<sup>(j)</sup>。例如，如果每个样本x在我们的集合代表一个人，然后第一个特征x<sup>(1)</sup>，可以包含高度（厘米），第二个特征x<sup>(2)</sup>，可以包含体重（千克），第三个特征x<sup>(3)</sup>可以包含性别等等。  

数据集中的所有样本，特征向量中位置j处的特征始终包含同样的信息。这意味着在某一样本x<sub>i</sub>中,如果x<sup>(2)</sup><sub>i</sub>包含重量（千克）的信息，那么，当k = 1 ,. 。 。 ，N时，在每个样本x<sub>k</sub>中的x<sup>(2)</sup><sub>k</sub>都会包含重量（千克）的信息。
要么是属于有限的一组类{1,2，...的元素。 。 。 ，C}，或实数，或更复杂的结构，如矢量，矩阵，树或图形。除非另有说明，否则本书yi是一组有限的类或实数2。你可以看到一个班级示例所属的类别。例如，如果您的示例是电子邮件并且您的问题是垃圾邮件检测，那么您有两个类{spam，not_spam}。

监督学习算法的目标是使用数据集生成一个模型，以特征向量x作为输入和输出信息以便推断标签特征向量。例如，使用人员数据集创建的模型可以视为输入描述一个人的特征向量，并输出该人患癌症的概率。


### 1.2.2 无监督学习   

在无监督学习中，数据集是未标记示例的集合 {Xi}<sup>N</sup>i=1
x 是一个特征向量，无监督学习算法的目标是创建一个以特征向量 x 作为输入并将它转换为另一个向量或数值来用于解决实际问题的模型。例如，在聚类中，模型返回数据集中每个特征向量的群集ID。在维度减少中，模型的输出是一个特征向量，其特征比输入的x要少;其输出是一个实数，预测x与数据集中的"典型"示例是如何不同的。

### 1.2.3 半监督学习   

在半监督学习中，数据集包含标记和未标记的示例。通常，未标记示例的数量远远高于标记示例的数量。半监督学习算法的目标与监督学习算法相同。希望使用许多未标记的示例可以帮助学习算法找到更好的模型（我们可以说"生成"或"计算"）。
学习可能因为添加更多未标记的示例而受益，这似乎有悖常理。似乎我们给这个问题增加了更多的不确定性。但是，当您添加未标记的示例时，会添加有关问题的详细信息：较大的示例反映了我们标记数据更好的概率分布。从理论上讲，学习算法应该能够利用这些附加信息。

### 1.2.4 强化学习  

强化学习是机器学习的一个子领域，机器"生活在"环境中，能够感知该环境的状态作为特征的载体。计算机可以在每种状态下执行操作。不同的行动带来不同的奖励，也可以将机器移动到环境的另一种状态。强化学习算法的目标是学习策略。
策略是一个函数（类似于监督学习中的模型），将状态的特征向量作为输入并输出，以该状态执行的最佳操作。如果操作是最佳的，则为最佳操作最大化预期的平均回报。
强化学习解决了一种特殊的问题，其中决策是连续的，目标是长期的，例如游戏、机器人、资源管理或物流。在此书，我强调一次性决策，其中输入实例是彼此独立的和过去式预测。我把强化学习排除在本书的讨论范围之内。  

## 1.3 监督学习的工作原理  

在这一部分中，我简要地解释了有监督的学习是如何工作的，这样在我们详细讨论之前的整个过程你脑海中就有了一定的画面。我决定把监督学习作为
例子，因为它是在实际中最常用的机器学习类型。  

监督学习的过程从收集数据开始。监督学习的数据是成对的集合（输入、输出）。输入可以是任何内容，例如电子邮件，信息，图片或传感器测量。输出通常是实数或标签（例如“垃圾邮件”、“非垃圾邮件”、“猫”、“狗”、“老鼠”等）。在某些情况下，输出是向量（例如，图片上一个人周围矩形的四个坐标），序列（例如[“形容词”，“形容词”、“名词”]表示输入“大且漂亮的车”），或有其他结构。  

假设您希望使用监督学习解决的问题是垃圾邮件检测。你收集数据，例如，10000封电子邮件，每个邮件都有一个标签“垃圾邮件”或“非垃圾邮件”（你可以手动添加这些标签，也可以花钱请人为我们添加）。现在，您必须将每个电子邮件转换为特征向量。  

数据分析师根据他们的经验决定如何将一个真实的实体转换一个特征向量，例如一封电子邮件。词袋模型是一种将文本转换为特征向量的常见方法，它是取一本英语单词词典（假设它包含20000个单词，其中单词是通过字母顺序划分的），并在我们的特征向量中规定：  

如果电子邮件中包含单词“a”，则第一个特征等于1;否则,这特征是0;  
  
如果电子邮件中包含单词“aaron”，则第二个特征等于1;否则，该特征值为0;  

**......**  

如果电子邮件中包含单词“zulu”，则第20000个特征等于1;否则，该特征值为0。  

您可以对我们集合中的每一封电子邮件重复上述步骤，我们的集合有10000个特征向量(每个向量的维数为20000)和一个标签(“垃圾邮件”/“非垃圾邮件”)。  

现在您有了一个机器可读的输入数据，但是输出标签仍然是人类可读的文本。一些学习算法需要把标签转换成数字。例如，有些算法需要像0这样的数字(表示标签“非垃圾邮件”)和1(表示“垃圾邮件”标签)。我用来解释监督学习的这种算法称为支持向量机(SVM)。该算法要求正标签(在此例中是“垃圾邮件”)，数值为+1(1)，负标签(“非垃圾邮件”)值为- 1。  

此时，您已经有了一个数据集和一个学习算法，所以您已经准备好应用学习算法，得到数据集的模型。  

SVM将每个特征向量看作高维空间中的一个点(在我们的例子中是高维空间是20000 -维)。该算法将所有特征向量放在一个假想的20,000-高维图，并绘制一个假想的19,999维的线(超平面)，它将带有正负面标签的例子分开。在机器学习中,将不同类的示例分隔开的边界称为决策边界。

超平面的方程由两个参数给出，一个实值向量w,它和输入特征向量x维数相同，和实数b。  

　　　　　　　　　　　　wx − b = 0
表示wx意味着w<sup>（１）</sup>x<sup>（１）</sup> + w<sup>（２）</sup>x<sup>（２）</sup> +…+ w<sup>（Ｄ）</sup>x<sup>（Ｄ）</sup>和D是代表特征向量x维度的数字。　　

（如果一些方程现在不清楚，在第 2 章中，我们重新审视数学和统计，理解它们所必需的概念。就目前而言，试着去了解此处是什么含义。阅读下一章后，一切都变得更加清晰。）　　

现在，一些输入的特征向量 x 的预测标签如下所示：　　

　　　　　　　　　　y = sign(wx − b),　　

其中*sign*是一个数学运算符，该运算符将任何值作为输入，如果输入为正例，返回+1。如果输入为负例，返回-1。  

学习算法 (本例中为 SVM)的目标是利用数据集并查找参数w<sup>星号</sup>和b<sup>*</sup>的最佳值w和b。  

一旦学习算法确定然后，将模型f(x)定义为：  
　　　　　　　　　f(x) = sign(w<sup>*</sup>x − b<sup>星</sup>)










## 1.4 模型为什么适用于新数据  

为什么机器学习模型能够正确预测以前新示例看不到的标签？要理解这一点，请查看图 1.1 中的图。如果两个类通过决策边界彼此分离，则属于每个类的示例显然位于决策边界创建的两个不同的子空间中。
如果用于训练的示例是随机选择的，彼此独立，并遵循相同的过程，那么，从统计上看，新的负例更有可能位于离其他负例不远的图上。同样，新的正例它很可能围绕在自其他正例。在这种情况下，我们的决定边界仍然极有可能将新的正负两方面的例子分开。对于其他不太可能的情况，我们的模型会出错，但由于此类情况的可能性较小，因此错误数可能小于正确预测的数量。
直观地说，训练示例集越大，**新示例与用于训练的示例，不同的可能性就越小。**(还需校对)。  

为了尽可能降低在新示例中出错的可能性，SVM 算法通过查找最大的边距，精确试图绘制决策边界，使它尽可能远离从两个类的示例。
有兴趣更多地了解可学习性和了解模型误差之间的密切关系，训练集的大小，数学方程的形式定义模型，构建模型所需的时间的读者，鼓励阅读有关PAC的内容。PAC（"可能近似正确"）学习理论有助于分析学习算法在什么条件下或者说可能在什么条件下输出一个近似正确的分类器。
